/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 *
 * @format
 * @flow
 */

import React, { Component } from "react";
import TimerCountdown from "react-native-timer-countdown";
import moment from "moment";
import RNAlarmClock from "react-native-alarm-clock";
import { notifyUpdateResult } from "./functions/notifications";
import ReactNativeAN from "react-native-alarm-notification";
import axios from "axios";
import { LineChart } from "react-native-chart-kit";
import PushNotification from "react-native-push-notification";
import { Button } from "react-native-elements";
import {
  Platform,
  AsyncStorage,
  StyleSheet,
  NetInfo,
  Text,
  StatusBar,
  Dimensions,
  View
} from "react-native";
// import axios from "axios";
import BackgroundTimer from "react-native-background-timer";
import ScheduleItem from "./components/scheduleitem";

export default class App extends React.Component {
  state = {
    isConnected: false,
    appShouldUpdate: false,
    someText: "null",
    data: null,
    dateNow: moment("January 2 2019 10:07 AM")
      .format("LLL")
      .toString(),
    lastScheduleUpdate: "null"
  };
  makeNotification() {
    PushNotification.localNotification({
      /* Android Only Properties */
      id: "0", // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
      ticker: "Time is coming!", // (optional)
      autoCancel: true, // (optional) default: true
      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
      bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
      subText: "This is a subText", // (optional) default: none
      color: "green", // (optional) default: system default
      vibrate: true, // (optional) default: true
      vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
      tag: "some_tag", // (optional) add tag to message
      group: "group", // (optional) add group to message
      ongoing: false, // (optional) set whether this is an "ongoing" notification
      priority: "high", // (optional) set notification priority, default: high
      visibility: "private", // (optional) set notification visibility, default: private
      importance: "high", // (optional) set notification importance, default: high

      /* iOS and Android properties */
      title: "My Notification Title", // (optional)
      message: "My Notification Message", // (required)
      playSound: false, // (optional) default: true
      soundName: "default", // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
      number: "10", // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
      // repeatType: "day", // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
      actions: '["Yes", "No"]' // (Android only) See the doc for notification actions to know more
    });
  }
  componentDidMount() {
    var ref = this;
    // var count = 1;
    // var minutes = 8;
    AsyncStorage.getItem("dateNow", (error, result) => {
      if (!result) {
        AsyncStorage.setItem(
          "dateNow",
          moment()
            .format("LLL")
            .toString()
        );
        this.setState({
          ...this.state,
          dateNow: moment()
            .format("LLL")
            .toString()
        });
      } else {
        this.setState({
          ...this.state,
          dateNow: result
        });
      }
    });
    AsyncStorage.getItem("lastUpdate", (error, result) => {
      if (result) {
        this.setState({
          ...this.state,
          lastScheduleUpdate: result
        });
      }
    });
    const timeLeft = ref.getRemainingTime();
    BackgroundTimer.setTimeout(function() {
      ref.setState(
        {
          ...ref.state,
          data: null
        },
        () => ref.fetchNewSchedule()
      );
      BackgroundTimer.setInterval(function() {
        ref.setState(
          {
            ...ref.state,
            data: null
          },
          () => ref.fetchNewSchedule()
        );
      }, 86400000);
    }, timeLeft);
    // NetInfo.isConnected.fetch().then(res => {
    //   if (ref.state.appShouldUpdate) {
    //     ref.setState({
    //       ...this.state,
    //       someText: "it's working"
    //     });
    //   }
    //   ref.setState({
    //     isConnected: res
    //   });
    // });
    // function handleFirstConnectivityChange(res) {
    //   ref.setState({
    //     isConnected: res
    //   });
    // }
    // NetInfo.isConnected.addEventListener(
    //   "connectionChange",
    //   handleFirstConnectivityChange
    // );
    this.getScheduleFromStorage();
  }

  render() {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="light-content" backgroundColor="#786BFF" />
        <View
          style={[
            styles.itemcontainer,
            { flexDirection: "column", flex: 4, marginBottom: 10 }
          ]}
        >
          <View
            style={{
              justifyContent: "center",
              alignItems: "center",
              backgroundColor: "#786BFF",
              flex: 2.3
            }}
          >
            <Text style={{ fontSize: 80, color: "white" }}>
              {moment(this.state.dateNow)
                .diff(moment().format("LLL"), "days")
                .toString()}
            </Text>
            <Text style={{ fontSize: 20, fontWeight: "bold", color: "white" }}>
              Days Elapsed
            </Text>
            <Button
              title="Reset"
              borderRadius={20}
              buttonStyle={{ height: 18, marginTop: 15 }}
              textStyle={{ fontSize: 15 }}
              onPress={() => {
                AsyncStorage.setItem("dateNow", moment().format("LLL"));
                this.setState({
                  ...this.state,
                  dateNow: moment()
                    .format("LLL")
                    .toString()
                });
              }}
              outline
            />
          </View>
          <View style={{ flex: 1, flexDirection: "row" }}>
            <View
              style={{
                flex: 2,
                justifyContent: "center",
                alignItems: "center"
              }}
            >
              <Text style={styles.label}>Next schedule updates</Text>
              <TimerCountdown
                initialSecondsRemaining={this.getRemainingTime()}
                allowFontScaling={true}
                style={[styles.welcome, { color: "#aaaaaa" }]}
                formatSecondsRemaining={milliseconds => {
                  const remainingSec = Math.round(milliseconds / 1000);
                  const seconds = parseInt((remainingSec % 60).toString(), 10);
                  const minutes = parseInt(
                    ((remainingSec / 60) % 60).toString(),
                    10
                  );
                  const hours = parseInt((remainingSec / 3600).toString(), 10);
                  const s = seconds < 10 ? "0" + seconds : seconds;
                  const m = minutes < 10 ? "0" + minutes : minutes;
                  let h = hours < 10 ? "0" + hours : hours;
                  h = h === "00" ? "" : h;
                  return `${h}h ${m}m ${s}s`;
                }}
              />
            </View>
            <View
              style={{
                flex: 2,
                justifyContent: "center",
                alignItems: "center"
              }}
            >
              <Text style={[styles.label]}>Last schedule updates</Text>
              <Text
                style={[styles.welcome, styles.label, { color: "#aaaaaa" }]}
              >
                {this.state.lastScheduleUpdate}
              </Text>
            </View>
          </View>
        </View>
        <View style={[styles.itemcontainer, { flex: 6 }]}>
          {this.state.data != null ? (
            <React.Fragment>
              <ScheduleItem name="Shubuh" time={this.state.data.Fajr} />
              <ScheduleItem name="Dzuhur" time={this.state.data.Dhuhr} />
              <ScheduleItem name="Ashar" time={this.state.data.Asr} />
              <ScheduleItem name="Maghrib" time={this.state.data.Maghrib} />
              <ScheduleItem name="Isya" time={this.state.data.Isha} />
            </React.Fragment>
          ) : (
            <View>
              <View style={{ alignSelf: "center" }}>
                <Text>
                  Schedules are either outdated or failed to retrieve.
                </Text>
              </View>
              <View style={{ marginTop: 20, alignSelf: "center" }}>
                <Button
                  buttonStyle={{ height: 39, alignSelf: "center" }}
                  title="Retry"
                  borderRadius={15}
                  backgroundColor="#786BFF"
                  onPress={this.fetchNewSchedule}
                />
              </View>
            </View>
          )}
        </View>
      </View>
    );
  }

  getRemainingTime() {
    const currentTime = new Date().getTime(); //current unix timestamp
    const execTime = new Date().setHours(0, 0, 0, 0); //API call time = today at 20:00

    if (currentTime < execTime) {
      //it's currently earlier than 20:00
      timeLeft = execTime - currentTime;
    } else {
      //it's currently later than 20:00, schedule for tomorrow at 20:00
      timeLeft = execTime + 24 * 60 * 60 * 1000 - currentTime;
    }
    return timeLeft;
  }

  fetchNewSchedule = () => {
    axios({
      method: "get",
      url: "https://time.siswadi.com/pray/bandung",
      timeout: 15 * 1000
    })
      .then(result => {
        AsyncStorage.setItem("schedule", JSON.stringify(result.data.data));
        AsyncStorage.setItem("appShouldFetchSchedule", false);
        AsyncStorage.setItem(
          "lastUpdate",
          moment().format("DD MMM YYYY h:mm:ss")
        );
        this.setState(
          {
            ...this.state,
            data: result.data.data,
            lastScheduleUpdate: moment().format("DD MMM YYYY h:mm:ss")
          },
          () => {
            this.setAlarm();
            notifyUpdateResult(
              `Schedule updated successfully at ${moment().format(
                "DD MMM YYYY h:mm:ss"
              )}`
            );
          }
        );
      })
      .catch(error =>
        notifyUpdateResult(
          `Schedule update failed at ${moment().format("DD MMM YYYY h:mm:ss")}`
        )
      );
  };
  getScheduleFromStorage() {
    AsyncStorage.getItem("schedule", (error, result) => {
      if (result) {
        this.setState({
          ...this.state,
          data: JSON.parse(result)
        });
      }
    });
  }
  setAlarm() {
    var count = 0;
    const time = [
      { name: "Shubuh", time: this.state.data.Fajr.split(":") },
      { name: "Dzuhur", time: this.state.data.Dhuhr.split(":") },
      { name: "Ashar", time: this.state.data.Asr.split(":") },
      { name: "Maghrib", time: this.state.data.Maghrib.split(":") },
      { name: "Isya", time: this.state.data.Isha.split(":") }
    ];
    const intervalId = BackgroundTimer.setInterval(() => {
      if (count < 5) {
        RNAlarmClock.createAlarm(
          time[count].name,
          parseInt(time[count].time[0]),
          parseInt(time[count].time[1])
        );
        count++;
      } else {
        BackgroundTimer.clearInterval(intervalId);
      }
    }, 9000);
  }
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: "#DFE4E9",
    flexDirection: "column",
    flex: 1
  },
  label: {
    fontSize: 16,
    color: "#786BFF"
  },
  welcome: {
    fontSize: 20,
    textAlign: "center",
    marginTop: 10
  },
  instructions: {
    textAlign: "center",
    color: "#333333",
    marginBottom: 5
  },
  itemcontainer: {
    backgroundColor: "white",
    justifyContent: "center"
  }
});
